#!/usr/bin/env python3

class CallFetcher:

    def __init__(self):
        pass

    # Generator to yield the next call identifier.
    # In the case where 1 call log = 1 file, this might be the local pathname to the file.
    # If there's more than one call per file, this might be a tuple of pathname, index.
    # (e.g. OSDM logs; Viecore Vista logs)
    # If the call is in a database, this might be an ID used to fetch the call.
    # If the call is in some kind of cloud storage (e.g. AWS s3), this is whatever
    # key you need to fetch the call data.
    # The identifier can be a string, or any other Python data structure such as tuple.
    def get_next_call_identifier(self):
        raise NotImplementedError


    # If you want to select just certain call identifiers, subclass your
    # call fetcher class, and override this method.
    # Return True if you want get_next_call() to return the call.
    # Return False if you want get_next_call() to skip the call.
    def _filter_call_identifier(self, call_identifier):
        return True
    
    # Take a call identifier (typically one generated by get_next_call_identifier),
    # and get back the actual data for the call.
    # If 1 call log = 1 file, read the file and return its contents.
    # If the call is in a database, query the database and return some kind of data blob.
    def get_call_record(self, call_identifier):
        raise NotImplementedError


    # This is the normal means for getting the contents of the next call.
    def get_next_call(self, max_count=None):
        for counter, call_identifier in enumerate(self.get_next_call_identifier()):
            call_record = self.get_call_record(call_identifier)

            if not self._filter_call_identifier(call_identifier):
                continue
            
            yield(call_identifier, call_record)

            if max_count is not None:
                if counter > max_count:
                    return

